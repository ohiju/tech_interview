# 정렬 알고리즘(Sorting Algorithm)

### 알고리즘
- 어떤 문제를 해결하기 위한 동작들의 절차

### 개념
- 데이터 탐색을 위해서 원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘
- 데이터의 정규화나 의미있는 결과물을 생성함

### 시간 복잡도
- CS 용어로, 컴퓨터 프로그램의 입력값과 연산 수행 시간의 상관 관계를 나타내는 척도(알고리즘이 결과를 도출하는 데 걸리는 시간의 값) <-> 공간 복잡도(알고리즘이 결과를 도출하는 데 필요한 공간의 값)
- 점근 표기법을 이용
  - 점근 표기법(란다우 표기법): 수리과학의 여러 분야에서 함수의 증감 추세를 비교하는 표기법
- 위로 갈수록 간단하고 빠르며, 아래로 갈수록 복잡함
  - O(1)과 같은 상수 형태
  - O(lon n)과 같은 로그 형태
  - O(n)과 같은 선형
  - O(n log n)과 같은 선형로그 형태
  - O(n^c), O(n^3)과 같은 다차형태
  - O(c^n), O(3^n)과 같은 지수형태
  - O(n!)과 같은 팩토리얼 형태
- **최악: O(n^2)**
  - 계산 시간이 정렬할 자료의 수의 제곱에 비례해서 증가
  - 1만개 1초 -> 10만개 100초
  - 최선: O(n), 평균: O(n)

## 삽입 정렬(Insertion Sort)
### 개념
- 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 삽입함으로써 정렬을 완성하는 알고리즘
- 손 안의 카드를 정렬하는 방법과 유사
  - 새로운 카드를 기존의 정렬된 카드 사이의 올바른 자리를 찾아 삽입
  - 새로 삽입될 카드의 수만큼 반복하게 되면 전체 카드가 정렬됨

### 원리 예시

- 31 25 12 22	11
- [31]
- 처음 상태.
- 31 `25` 12 22 11
- [31]
- 두 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.
- `25` 31	`12` 22	 11
- [25, 31]
- 세 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.
- `12` 25 31 `22` 11		 	
- [12, 25, 31]
- 네 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.
- 12 `22` 25 31 `11`		 
- [12, 22, 25, 31]
- 마지막 원소를 부분 리스트에서 적절한 위치에 삽입한다.
- `11` 12 22 25 31		 	
- 종료.


### 파이썬 예시
```python
def insert_sort(x):
	for i in range(1, len(x)):
		j = i - 1
		key = x[i]
		while x[j] > key and j >= 0:
			x[j+1] = x[j]
			j = j - 1
		x[j+1] = key
	return x
```

### 장점
- 알고리즘 자체가 매우 간단하므로 특정 크기 이하가 됐을 때 작은 규모에서 강점을 보임
- 구현이 비교적 간단함
- 안정적인 정렬 방법으로 이미 정렬되어 있는 자료구조에 사용할 경우 매우 효율적임
- 선택 정렬과 함께 무의식적으로 정렬하라고 하면 사용하는 대표적인 알고리즘

### 단점
- 비교적 많은 이동이 있음
- 자료구조의 수가 많고 크기가 클 경우에는 매우 비효율적이므로 적합하지 않을 수 있음

### 이진 삽입
- 파생형으로 이진 삽입 정렬 존재
- 이진 탐색을 활용해 새로운 원소가 위치할 곳을 미리 찾아서 정렬하는 방식
- 이진 탐색(Binary Search): 검색 범위를 줄여 나가면서 원하는 데이터를 검색하는 알고리즘
  - 오름차순으로 정렬된 정수의 리스트를 같은 크기의 두 부분 리스트로 나누고, 원하는 데이터를 검색하기위해서 그 리스트들을 비교하며 계속 반복하며 찾는 것