# Quick Sort(퀵 정렬)
- 1960년에 찰스 엔터니 리처드 호어가 개발. 이후에 많은 사람들이 수정하고 보완

# 1. 과정 설명
1. 리스트의 안의 임의의 한 요소를 설정한다. 이것을 피봇(pivot)이라고 한다.
2. 피봇값을 기준으로 피봇값보다 작은 요소들은 모두 피봇의 왼쪽으로 옮겨지고 피벗보다 큰 요소는 모두 피봇의 오른쪽으로 옮긴다. 이 과정 후 피봇값의 위치는 고정.
    
     (ex) 3 5 2 7 8  =>  [3, 2] 5 [7, 8]
    
3. 피봇을 제외한 왼쪽 리스트와 오른쪽 리스트에서 같은 방식으로 다시 정렬한다.
4. 더 이상 리스트 분할이 불가능할떄까지 이 과정을 반복한다.

## 1.1 구현 예시
1. 피봇값을 설정한 후, 왼쪽부터는 피봇값보다 큰 수를, 오른쪽부터는 피봇값보다 작은 수를 찾아준다.
2. 발견하면 큰 값과 작은 값의 위치를 바꾸어준다.
3. 계속 발견하다가 큰 수를 찾는 방향과 작은 수를 찾는 방향이 교차하게 된다면 피봇값과 작은수의 위치를 바꾸어준다.
4. 피봇값의 위치는 고정이 되고, 피봇값을 기준으로 양쪽의 리스트에서 이 과정을 반복한다.
5. 모든 리스트의 길이가 0이나 1이 되면 이 과정을 종료한다. 


```python
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end) :
	if start >= end :  # 원소가 1개인 경우 종료
		return 
	pivot = start  # 피벗은 첫번째 원소
	left = start + 1
	right = end
	#교차할때까지 반복
	while(lef <= right) :
		#피벗보다 큰 데이터를 찾을때까지 반복
		while(left <= end and array[left] <= array[pivot]) :
			left += 1
		# 피벗보다 작은 데이터를 찾을 때까지 반복
		while (right > start and array[right] >= array[pivot] ) :
			right -= 1
		if (left > right) : # 엇갈렸다면 작은 데이터와 피벗을 교체
			array[right], array[pivot] = array [pivot], array[right]
		else : # 엇갈리지 않았다면 작은 데이터와 큰 데이터
			array[left], array[right] array[right], array[left]
	#분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
	quick_sort(array, start, right - 1)
	quick_sort(arry, right+1, end)

quick_sort(array, 0, len(array)-1)
print(array)
```
```python
#더 간결한 방식
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]
def quick_sort(array) :
	# 리스트가 하나 이하의 원소만을 담고 있다면 종료
	if len(array) <= 1:
		return array
	pivot = array[0] # 피벗은 첫 번째 원소
	tail = array[1:] # 피벗을 제외한 리스트
	
	left_side = [x for x in tail if x <= pivot] #분할된 왼쪽 부분.. 피봇값보다 작은 것만
	right_side = [x for x in tail if x > pivot] #분할된 왼쪽 부분
	
	return quick_sort(left_side) + [pivot] + quick_sort(right_side) 
print(quick_sort(array))
```

# 2. 시간 복잡도 
  최 선 | 평 균 | 최 악
|----|----|----|
O(NlogN) |O(NlogN) | O(N^2) 

    
## 2.1 최선의 경우
 피봇값이 매번 중위값이 선택되면 배열이 계속 반씩 나누어진다.   
 따라서 최선의 경우 배열이 균등하게 이등분되어 순환호출의 깊이는 log N,   
 각각의 단계에서 피봇의 위치를 고정시키기 위한 비교연산횟수는 평균적으로 N번 이루어진다.  

` 3, 2, 1, 4, 5  # 피봇이 중위값으로 설정된 경우`  
` [2, 1] 3, [4, 5] # 정확히 반씩 쪼개진다.`   
 
 #### 따라서 시간복잡도는 O(NlogN) 
 
## 2.2 최악의 경우 
 피봇값이 매번 최소값이나 최대값을 고른다면 피봇을 고정시키고 난 후에도 나누어진 배열의 크기는 전 단계에 비해 1밖에 줄어들지 않는다.  

 `[5, 4, 3, 2, 1 ] # 피봇을 배열의 첫번째 숫자로 정한 경우`    
 `[4, 3, 2, 1] 5`  
 `[3, 2, 1] 4 5`  

 따라서 배열의 길이가 1이 될때까지 총 N-1번을 쪼개야 하고, 각 단계에서 피봇 위치를 고정시키기 위한 비교연산 횟수는 평균적으로 N번이므로  

#### 총 N*(N-1)의 시간복잡도를 가지게 된다.

## 2.3 평균
n-1번 쪼개는 동안 모두 최소값이나 최대값을 고를 확률은 아주작다.  

` 한 단계에서 최대값이나 최소값을 고를 확률 = 2 / N `  
` 모든 단계에서 최대값이나 최소값을 고를 확률 = (2 / N) ^ N`  
` N이 무한히 커지면 이 확률은 0에 수렴한다.`
#### 따라서  평균적으로는 NlogN의 시간복잡도를 가진다. 
  
    

  
  

# 3. 장단점
## 3.1 장점
### 1. 추가적인 공간이 필요하지 않다
병합 정렬은 조합 단계에서 새로운 배열을 만들어야 하지만, 퀵 정렬은 새로운 배열을 만들지 않고 합칠 수 있다.
### 2. 평균적인 경우 O(Nlog N) 정렬보다 빠르다.
추가적인 공간을 할당하지도 않고, 한번 결정한 피벗이 연산에서 제외되는 등의 이유 때문에 실제로 돌려보면 힙 정렬, 합병 정렬보다 약간 더 빠르다고 한다. 

## 3.2 단점
### 1. 시간복잡도가 최악의 경우 O(N^2)이다.
피봇값을 설정할 떄 가장 좋은 방법은 중위값을 고르는 것이지만, 정렬되지 않은 상태에서 중위값을 고르기는 힘들다.   
특히 이미 정렬된 배열이 들어온 경우( [5, 4, 3, 2, 1]..) 시간복잡도가 최악이 된다. (i번째 요소에 계속 최소값/최대값이 있는 경우)   

따라서 이러한 경우 **피봇값을 랜덤으로 설정하는 방식**으로 계속해서 최솟값이나 최댓값을 선택할 확률을 줄인다. 
 



## 4.    추가
### Q. 특정 알고리즘이 평균적으로 제일 우세하면 그 알고리즘만 쓴다?

**A. 상황에 따라 적합한 알고리즘은 다르다.** 

실제 java jdk의 Arrays.sort()의 내부를 보면 인자의 타입이 원시타입이면 DualPivotQuickSort가, Object이면 TimeSort가 적용된다. 이때 DualPivotQuickSort의 내부를 보면 이름과는 다르게 merge sort, quick sort, insertion sort 등으로 이루어져있다.   

47개 이하의 요소를 가진 배열에서는 삽입정렬, 286 이하이면 퀵 소트, 그 이상은 머지소트를 사용한다. 

그 이유는 퀵 소트 같은 경우 수가 적은 배열에서는 오히려 코스트가 많이 발생할 수 있기 떄문이다. 

또한 수가 적은 배열에서는 경험적으로 수가 어느 정도 정렬이 되어 있다고 판단했기 때문에 47개(경험적으로 정해진 수) 이하의 배열에서는 모두 정렬된 리스트에서는 O(n)의 시간복잡도를 가지는 삽입정렬을 채택한 것이다.



결론 :  O(nlogn)이 무조건 좋은 건 아니다. 상황에 적합한 정렬알고리즘이 무엇일지 생각을 해보자.